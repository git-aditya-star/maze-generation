{"ast":null,"code":"import { Cell } from './cell';\n/**\r\n * A rectangle maze generated based on \"hunt-and-kill\" algorithm.\r\n */\n\nexport class Maze {\n  /**\r\n   * Create a maze with <row> &times; <col> cells.\r\n   * @param nRow number of rows\r\n   * @param nCol number of columns\r\n   */\n  constructor(nRow, nCol) {\n    this.nRow = nRow;\n    this.nCol = nCol;\n    this.cells = []; // initialize cells\n\n    for (let i = 0; i < nRow; i++) {\n      this.cells[i] = [];\n\n      for (let j = 0; j < nCol; j++) {\n        this.cells[i][j] = new Cell(i, j);\n      }\n    } // populate cell neighbors (an optimization)\n\n\n    this.cells.forEach(row => row.forEach(c => this.mapNeighbors(c))); // generate maze\n\n    this.randomRowNumbers = Utils.shuffleArray([...Array(this.nRow).keys()]);\n    this.randomColNumbers = Utils.shuffleArray([...Array(this.nCol).keys()]);\n    this.huntAndKill();\n  }\n\n  get firstCell() {\n    return this.cells[0][0];\n  }\n\n  get lastCell() {\n    return this.cells[this.nRow - 1][this.nCol - 1];\n  }\n\n  get randomCell() {\n    return this.cells[Utils.random(this.nRow)][Utils.random(this.nCol)];\n  }\n  /**\r\n   * traverse the maze using depth-first algorithm\r\n   */\n\n\n  findPath() {\n    this.cells.forEach(x => x.forEach(c => c.traversed = false));\n    const path = [this.firstCell];\n\n    while (1) {\n      let current = path[0];\n      current.traversed = true;\n\n      if (current.equals(this.lastCell)) {\n        break;\n      }\n\n      const traversableNeighbors = current.neighbors.filter(c => c.isConnectedTo(current)).filter(c => !c.traversed);\n\n      if (traversableNeighbors.length) {\n        path.unshift(traversableNeighbors[0]);\n      } else {\n        path.splice(0, 1);\n      }\n    }\n\n    return path.reverse();\n  }\n\n  huntAndKill() {\n    let current = this.randomCell; // hunt-and-kill starts from a random Cell\n\n    while (current) {\n      this.kill(current);\n      current = this.hunt();\n    }\n  }\n\n  kill(current) {\n    while (current) {\n      const next = current.neighbors.find(c => !c.visited);\n\n      if (next) {\n        current.connectTo(next);\n      }\n\n      current = next;\n    }\n  }\n\n  hunt() {\n    for (let huntRow of this.randomRowNumbers) {\n      for (let huntColumn of this.randomColNumbers) {\n        const cell = this.cells[huntRow][huntColumn];\n\n        if (cell.visited) {\n          continue;\n        }\n\n        const next = cell.neighbors.find(c => c.visited);\n\n        if (next) {\n          cell.connectTo(next);\n          return cell;\n        }\n      }\n    }\n  }\n\n  mapNeighbors(cell) {\n    if (cell.row - 1 >= 0) {\n      cell.neighbors.push(this.cells[cell.row - 1][cell.col]);\n    }\n\n    if (cell.row + 1 < this.nRow) {\n      cell.neighbors.push(this.cells[cell.row + 1][cell.col]);\n    }\n\n    if (cell.col - 1 >= 0) {\n      cell.neighbors.push(this.cells[cell.row][cell.col - 1]);\n    }\n\n    if (cell.col + 1 < this.nCol) {\n      cell.neighbors.push(this.cells[cell.row][cell.col + 1]);\n    }\n\n    cell.neighbors = Utils.shuffleArray(cell.neighbors);\n  }\n\n}\n\nclass Utils {\n  static shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n      const temp = ~~(Math.random() * (i + 1));\n      [array[i], array[temp]] = [array[temp], array[i]];\n    }\n\n    return array;\n  }\n  /**\r\n   * Generate a random index within a number `n`\r\n   */\n\n\n  static random(n) {\n    return ~~(Math.random() * n);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}