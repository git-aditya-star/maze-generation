{"ast":null,"code":"import { Maze, keyboardMap } from './models';\nimport { environment } from 'D:/Maze generation/angular-maze/src/environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/forms\";\nexport let MazeComponent = /*#__PURE__*/(() => {\n  class MazeComponent {\n    constructor() {\n      this.row = 15;\n      this.col = 15;\n      this.cellSize = 20; // length of cell edge\n\n      this.cellEdgeThickness = 2; // thickness of cell edge\n\n      this.cellBackground = '#f8defa';\n      this.solutionPathColor = '#fcba03';\n      this.myPathColor = '#0bfc03';\n      this.myPathThickness = 10;\n      this.solutionPathThickness = 3;\n      this.gameOver = false;\n      this.myPath = [];\n      this.showTestButton = false;\n      this.busy = false;\n\n      if (!environment.production) {\n        this.showTestButton = true;\n      }\n    }\n\n    ngOnInit() {}\n\n    ngAfterViewInit() {\n      this.canvas = document.getElementById('maze');\n      this.ctx = this.canvas.getContext('2d');\n      this.drawMaze();\n    }\n\n    drawMaze() {\n      this.busy = true;\n      this.validateInputs();\n      this.maze = new Maze(this.row, this.col);\n      this.canvas.width = this.col * this.cellSize;\n      this.canvas.height = this.row * this.cellSize; // open the first and last cells to show the entrance and exit\n\n      this.maze.firstCell.westEdge = false;\n      this.maze.lastCell.eastEdge = false; // draw the cells\n\n      this.ctx.lineWidth = this.cellEdgeThickness;\n      this.ctx.fillStyle = this.cellBackground;\n      this.maze.cells.forEach(x => x.forEach(c => this.draw(c)));\n      this.initPlay();\n      this.busy = false;\n    }\n\n    initPlay() {\n      this.gameOver = false;\n      this.myPath.length = 0;\n      this.currentCell = this.maze.firstCell; // reset myPath position\n\n      this.myPath.push(this.currentCell); // draw the initial step of myPath in the first Cell as entrance\n\n      this.ctx.lineWidth = this.myPathThickness;\n      this.ctx.strokeStyle = this.myPathColor;\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, this.cellSize / 2);\n      this.ctx.lineTo(this.cellSize / 2, this.cellSize / 2);\n      this.ctx.stroke();\n    }\n\n    handleKeyDown(event) {\n      if (this.gameOver) return;\n      const direction = keyboardMap[event.key];\n\n      if (direction) {\n        this.move(direction);\n        event.preventDefault();\n      }\n    }\n\n    move(direction) {\n      let nextCell;\n\n      if (direction === 'Left') {\n        if (this.currentCell.col < 1) return;\n        nextCell = this.maze.cells[this.currentCell.row][this.currentCell.col - 1];\n      }\n\n      if (direction === 'Right') {\n        if (this.currentCell.col + 1 >= this.col) return;\n        nextCell = this.maze.cells[this.currentCell.row][this.currentCell.col + 1];\n      }\n\n      if (direction === 'Up') {\n        if (this.currentCell.row < 1) return;\n        nextCell = this.maze.cells[this.currentCell.row - 1][this.currentCell.col];\n      }\n\n      if (direction === 'Down') {\n        if (this.currentCell.row + 1 >= this.row) return;\n        nextCell = this.maze.cells[this.currentCell.row + 1][this.currentCell.col];\n      }\n\n      if (this.currentCell.isConnectedTo(nextCell)) {\n        if (this.myPath.length > 1 && this.myPath[this.myPath.length - 2].equals(nextCell)) {\n          // this is a step back; reverse the step by erasing the original path\n          this.drawPath(this.myPath, this.cellBackground);\n          this.myPath.pop();\n        } else {\n          this.myPath.push(nextCell);\n\n          if (nextCell.equals(this.maze.lastCell)) {\n            this.hooray();\n            this.drawSolution(this.myPathColor, this.myPathThickness);\n            return;\n          }\n        }\n\n        this.drawPath(this.myPath);\n        this.currentCell = nextCell;\n      }\n    }\n\n    undo(nSteps = 5) {\n      if (!this.gameOver && this.myPath.length > nSteps) {\n        this.drawPath(this.myPath, this.cellBackground);\n        this.myPath.splice(-nSteps);\n        this.drawPath(this.myPath);\n        this.currentCell = this.myPath[this.myPath.length - 1];\n      }\n    }\n\n    drawSolution(color = this.solutionPathColor, lineThickness = this.solutionPathThickness) {\n      this.gameOver = true;\n      this.drawPath(this.maze.findPath(), color, lineThickness, true);\n    }\n\n    drawPath(path, color = this.myPathColor, lineThickness = this.myPathThickness, drawSolution = false) {\n      this.ctx.lineWidth = lineThickness;\n      this.ctx.strokeStyle = color;\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, this.cellSize / 2);\n      path.forEach(x => this.ctx.lineTo((x.col + 0.5) * this.cellSize, (x.row + 0.5) * this.cellSize));\n\n      if (drawSolution) {\n        this.ctx.lineTo(this.col * this.cellSize, (this.row - 0.5) * this.cellSize);\n      }\n\n      this.ctx.stroke();\n    }\n\n    draw(cell) {\n      this.ctx.fillRect(cell.col * this.cellSize, cell.row * this.cellSize, (cell.col + 1) * this.cellSize, (cell.row + 1) * this.cellSize);\n\n      if (cell.northEdge) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(cell.col * this.cellSize, cell.row * this.cellSize);\n        this.ctx.lineTo((cell.col + 1) * this.cellSize, cell.row * this.cellSize);\n        this.ctx.stroke();\n      }\n\n      if (cell.eastEdge) {\n        this.ctx.beginPath();\n        this.ctx.moveTo((cell.col + 1) * this.cellSize, cell.row * this.cellSize);\n        this.ctx.lineTo((cell.col + 1) * this.cellSize, (cell.row + 1) * this.cellSize);\n        this.ctx.stroke();\n      }\n\n      if (cell.southEdge) {\n        this.ctx.beginPath();\n        this.ctx.moveTo((cell.col + 1) * this.cellSize, (cell.row + 1) * this.cellSize);\n        this.ctx.lineTo(cell.col * this.cellSize, (cell.row + 1) * this.cellSize);\n        this.ctx.stroke();\n      }\n\n      if (cell.westEdge) {\n        this.ctx.beginPath();\n        this.ctx.moveTo(cell.col * this.cellSize, (cell.row + 1) * this.cellSize);\n        this.ctx.lineTo(cell.col * this.cellSize, cell.row * this.cellSize);\n        this.ctx.stroke();\n      }\n    }\n\n    hooray() {\n      var audio = new Audio('assets/KidsCheering.mp3');\n      audio.play();\n    }\n\n    validateInputs() {\n      if (isNaN(this.row) || this.row < 1) {\n        alert('Please enter a positive number for #Rows.');\n        this.row = 15;\n      }\n\n      if (isNaN(this.col) || this.col < 1) {\n        alert('Please enter a positive number for #Columns.');\n        this.col = 15;\n      }\n\n      if (this.row > 500 || this.col > 500) {\n        alert('Size too large. You may crash the browser...');\n        this.row = 15;\n        this.col = 15;\n      }\n\n      this.row = ~~this.row;\n      this.col = ~~this.col;\n    }\n\n  }\n\n  MazeComponent.ɵfac = function MazeComponent_Factory(t) {\n    return new (t || MazeComponent)();\n  };\n\n  MazeComponent.ɵcmp = /*@__PURE__*/i0.ɵɵdefineComponent({\n    type: MazeComponent,\n    selectors: [[\"app-maze\"]],\n    hostBindings: function MazeComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function MazeComponent_keydown_HostBindingHandler($event) {\n          return ctx.handleKeyDown($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n    },\n    decls: 31,\n    vars: 3,\n    consts: [[2, \"text-align\", \"center\"], [1, \"maze-form\"], [\"for\", \"nRow\"], [1, \"badge\", \"badge-info\"], [\"id\", \"nRow\", \"type\", \"number\", \"min\", \"1\", \"max\", \"500\", 3, \"ngModel\", \"ngModelChange\"], [\"for\", \"nCol\"], [\"id\", \"nCol\", \"type\", \"number\", \"min\", \"1\", \"max\", \"500\", 3, \"ngModel\", \"ngModelChange\"], [\"type\", \"button\", 1, \"btn\", \"btn-success\", 3, \"disabled\", \"click\"], [\"type\", \"button\", 1, \"btn\", \"btn-danger\", 3, \"click\"], [\"id\", \"maze\"], [1, \"arrows\"], [\"title\", \"move up\", 3, \"click\"], [\"title\", \"move left\", 3, \"click\"], [\"title\", \"move right\", 2, \"margin-left\", \"30px\", 3, \"click\"], [\"title\", \"move down\", 3, \"click\"]],\n    template: function MazeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"label\", 2);\n        i0.ɵɵelementStart(3, \"h4\");\n        i0.ɵɵelementStart(4, \"span\", 3);\n        i0.ɵɵtext(5, \"Rows\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"input\", 4);\n        i0.ɵɵlistener(\"ngModelChange\", function MazeComponent_Template_input_ngModelChange_6_listener($event) {\n          return ctx.row = $event;\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(7, \"label\", 5);\n        i0.ɵɵelementStart(8, \"h4\");\n        i0.ɵɵelementStart(9, \"span\", 3);\n        i0.ɵɵtext(10, \"Columns\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(11, \"input\", 6);\n        i0.ɵɵlistener(\"ngModelChange\", function MazeComponent_Template_input_ngModelChange_11_listener($event) {\n          return ctx.col = $event;\n        });\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(12, \"button\", 7);\n        i0.ɵɵlistener(\"click\", function MazeComponent_Template_button_click_12_listener() {\n          return ctx.drawMaze();\n        });\n        i0.ɵɵtext(13, \" New Maze \");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(14, \"button\", 8);\n        i0.ɵɵlistener(\"click\", function MazeComponent_Template_button_click_14_listener() {\n          return ctx.drawSolution();\n        });\n        i0.ɵɵtext(15, \"Solution\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(16, \"section\");\n        i0.ɵɵelement(17, \"canvas\", 9);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(18, \"section\");\n        i0.ɵɵelementStart(19, \"div\", 10);\n        i0.ɵɵelementStart(20, \"div\");\n        i0.ɵɵelementStart(21, \"span\", 11);\n        i0.ɵɵlistener(\"click\", function MazeComponent_Template_span_click_21_listener() {\n          return ctx.move(\"Up\");\n        });\n        i0.ɵɵtext(22, \"\\u2B06\\uFE0F\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(23, \"div\");\n        i0.ɵɵelementStart(24, \"span\", 12);\n        i0.ɵɵlistener(\"click\", function MazeComponent_Template_span_click_24_listener() {\n          return ctx.move(\"Left\");\n        });\n        i0.ɵɵtext(25, \"\\u2B05\\uFE0F\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(26, \"span\", 13);\n        i0.ɵɵlistener(\"click\", function MazeComponent_Template_span_click_26_listener() {\n          return ctx.move(\"Right\");\n        });\n        i0.ɵɵtext(27, \"\\u27A1\\uFE0F\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(28, \"div\");\n        i0.ɵɵelementStart(29, \"span\", 14);\n        i0.ɵɵlistener(\"click\", function MazeComponent_Template_span_click_29_listener() {\n          return ctx.move(\"Down\");\n        });\n        i0.ɵɵtext(30, \"\\u2B07\\uFE0F\");\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngModel\", ctx.row);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngModel\", ctx.col);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"disabled\", ctx.busy);\n      }\n    },\n    directives: [i1.MinValidator, i1.MaxValidator, i1.NumberValueAccessor, i1.DefaultValueAccessor, i1.NgControlStatus, i1.NgModel],\n    styles: [\".maze-form[_ngcontent-%COMP%]{margin:1rem 0}.maze-form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{max-width:3rem;padding:.25rem;margin:0 .5rem}.maze-form[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]{padding:.25rem;margin:0 .5rem}.arrows[_ngcontent-%COMP%]   span[_ngcontent-%COMP%]{font-size:xx-large;-webkit-user-select:none;user-select:none;cursor:pointer;margin:auto .25rem}button[_ngcontent-%COMP%]{box-shadow:5px 10px 18px #888}button[_ngcontent-%COMP%]:hover{height:50px;width:100px}\"]\n  });\n  return MazeComponent;\n})();","map":null,"metadata":{},"sourceType":"module"}